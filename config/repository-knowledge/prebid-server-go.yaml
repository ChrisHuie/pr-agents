repository: prebid/prebid-server
type: prebid-server-go
description: Server-side header bidding solution in Go
version: 0.x
primary_language: Go
ecosystem: Server/Backend

# Repository overview
overview:
  purpose: "High-performance server-side header bidding for scalable programmatic advertising"
  key_features:
    - "Server-side auction execution"
    - "Reduced client-side latency"
    - "GDPR/CCPA compliance built-in"
    - "OpenRTB 2.5/2.6 protocol support"
    - "Multi-format support (banner, video, native, audio)"
    - "Advanced caching strategies"
    - "Prometheus metrics integration"
  
  architecture:
    core_components:
      - exchange: "Core auction engine"
      - adapters: "Bidder integrations"
      - stored_requests: "Configuration storage"
      - cache: "Bid response caching"
      - analytics: "Event tracking"
      - privacy: "Consent management"
      - metrics: "Performance monitoring"
    
    design_patterns:
      - "Interface-based adapter system"
      - "Middleware pipeline for request processing"
      - "Dependency injection for testability"
      - "Context-based cancellation"

# Directory structure
directory_structure:
  adapters:
    description: "Bidder adapter implementations"
    structure:
      - "{bidder}/": "Each bidder in its own package"
      - "adapterstest/": "Test utilities and fixtures"
      - "info_fetcher.go": "Adapter info registry"
    
    example_files:
      - "example_adapter.go": "Adapter implementation"
      - "example_adapter_test.go": "Unit tests"
      - "params_test.go": "Parameter validation tests"
  
  openrtb_ext:
    description: "OpenRTB protocol extensions"
    subdirectories:
      - "bidders/": "Bidder-specific parameters"
      - "request.go": "Request extensions"
      - "response.go": "Response extensions"
  
  endpoints:
    description: "HTTP endpoint handlers"
    key_files:
      - "openrtb2/": "OpenRTB 2.x endpoints"
      - "events/": "Event tracking endpoints"
      - "info/": "Information endpoints"
      - "cookie_sync/": "Cookie sync endpoints"
  
  exchange:
    description: "Core auction logic"
    components:
      - "exchange.go": "Main auction engine"
      - "bidder.go": "Bidder interface"
      - "targeting.go": "Key-value targeting"
      - "price_granularity.go": "Price bucketing"
  
  stored_requests:
    description: "Stored configuration system"
    backends:
      - "filesystem/": "File-based storage"
      - "database/": "Database storage"
      - "http/": "HTTP-based storage"

# Code examples with full context
code_examples:
  bidder_adapter:
    complete_example:
      description: "Full bidder adapter implementation in Go"
      code: |
        package example
        
        import (
            "encoding/json"
            "fmt"
            "net/http"
            "strconv"
            
            "github.com/prebid/openrtb/v19/openrtb2"
            "github.com/prebid/prebid-server/v2/adapters"
            "github.com/prebid/prebid-server/v2/config"
            "github.com/prebid/prebid-server/v2/errortypes"
            "github.com/prebid/prebid-server/v2/openrtb_ext"
        )
        
        type adapter struct {
            endpoint string
        }
        
        // Builder builds a new instance of the Example adapter for the given bidder with the given config.
        func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) {
            endpoint := config.Endpoint
            if endpoint == "" {
                return nil, fmt.Errorf("endpoint is required for %s adapter", bidderName)
            }
            
            bidder := &adapter{
                endpoint: endpoint,
            }
            return bidder, nil
        }
        
        // MakeRequests creates HTTP requests for the bidder
        func (a *adapter) MakeRequests(request *openrtb2.BidRequest, requestInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) {
            var errors []error
            var requests []*adapters.RequestData
            
            // Validate request
            if err := validateRequest(request); err != nil {
                errors = append(errors, err)
                return nil, errors
            }
            
            // Create a copy of the request for modifications
            requestCopy := *request
            
            // Process each impression
            for i, imp := range request.Imp {
                // Parse bidder-specific extension
                var bidderExt adapters.ExtImpBidder
                if err := json.Unmarshal(imp.Ext, &bidderExt); err != nil {
                    errors = append(errors, &errortypes.BadInput{
                        Message: fmt.Sprintf("failed to parse imp[%d].ext: %v", i, err),
                    })
                    continue
                }
                
                var exampleExt openrtb_ext.ExtImpExample
                if err := json.Unmarshal(bidderExt.Bidder, &exampleExt); err != nil {
                    errors = append(errors, &errortypes.BadInput{
                        Message: fmt.Sprintf("failed to parse imp[%d].ext.bidder: %v", i, err),
                    })
                    continue
                }
                
                // Validate required parameters
                if exampleExt.PlacementID == "" {
                    errors = append(errors, &errortypes.BadInput{
                        Message: fmt.Sprintf("imp[%d].ext.bidder.placementId is required", i),
                    })
                    continue
                }
                
                // Add custom fields to impression
                impCopy := imp
                impCopy.TagID = exampleExt.PlacementID
                requestCopy.Imp[i] = impCopy
            }
            
            // If all impressions failed validation, return early
            if len(errors) == len(request.Imp) {
                return nil, errors
            }
            
            // Add custom headers and parameters
            headers := http.Header{}
            headers.Add("Content-Type", "application/json")
            headers.Add("X-Prebid-Server", "true")
            
            // Marshal the modified request
            requestJSON, err := json.Marshal(requestCopy)
            if err != nil {
                errors = append(errors, err)
                return nil, errors
            }
            
            requestData := &adapters.RequestData{
                Method:  "POST",
                Uri:     a.endpoint,
                Body:    requestJSON,
                Headers: headers,
            }
            
            requests = append(requests, requestData)
            return requests, errors
        }
        
        // MakeBids unpacks the server's response into bids
        func (a *adapter) MakeBids(request *openrtb2.BidRequest, requestData *adapters.RequestData, responseData *adapters.ResponseData) (*adapters.BidderResponse, []error) {
            if responseData.StatusCode == http.StatusNoContent {
                return nil, nil
            }
            
            if responseData.StatusCode != http.StatusOK {
                return nil, []error{&errortypes.BadServerResponse{
                    Message: fmt.Sprintf("unexpected status code: %d. Run with request.debug = 1 for more info", responseData.StatusCode),
                }}
            }
            
            var response openrtb2.BidResponse
            if err := json.Unmarshal(responseData.Body, &response); err != nil {
                return nil, []error{err}
            }
            
            bidResponse := adapters.NewBidderResponseWithBidsCapacity(len(response.SeatBid))
            bidResponse.Currency = response.Cur
            
            var errors []error
            for _, seatBid := range response.SeatBid {
                for i, bid := range seatBid.Bid {
                    // Find the impression for this bid
                    imp, err := findImpByID(bid.ImpID, request.Imp)
                    if err != nil {
                        errors = append(errors, err)
                        continue
                    }
                    
                    // Determine bid type
                    bidType, err := getMediaTypeForBid(bid, imp)
                    if err != nil {
                        errors = append(errors, err)
                        continue
                    }
                    
                    // Build typed bid
                    typedBid := &adapters.TypedBid{
                        Bid:     &seatBid.Bid[i],
                        BidType: bidType,
                    }
                    
                    // Add meta information if available
                    if bid.Ext != nil {
                        var bidExt openrtb_ext.ExtBid
                        if err := json.Unmarshal(bid.Ext, &bidExt); err == nil {
                            if bidExt.Prebid != nil && bidExt.Prebid.Meta != nil {
                                typedBid.BidMeta = bidExt.Prebid.Meta
                            }
                        }
                    }
                    
                    bidResponse.Bids = append(bidResponse.Bids, typedBid)
                }
            }
            
            return bidResponse, errors
        }
        
        // Helper functions
        
        func validateRequest(request *openrtb2.BidRequest) error {
            if request.ID == "" {
                return &errortypes.BadInput{Message: "request.id is required"}
            }
            
            if len(request.Imp) == 0 {
                return &errortypes.BadInput{Message: "request must contain at least one impression"}
            }
            
            return nil
        }
        
        func findImpByID(impID string, imps []openrtb2.Imp) (*openrtb2.Imp, error) {
            for _, imp := range imps {
                if imp.ID == impID {
                    return &imp, nil
                }
            }
            return nil, &errortypes.BadServerResponse{
                Message: fmt.Sprintf("bid with imp id %s does not match any impression in request", impID),
            }
        }
        
        func getMediaTypeForBid(bid openrtb2.Bid, imp *openrtb2.Imp) (openrtb_ext.BidType, error) {
            // Check for explicit media type in bid extension
            if bid.Ext != nil {
                var bidExt map[string]interface{}
                if err := json.Unmarshal(bid.Ext, &bidExt); err == nil {
                    if mediaType, ok := bidExt["mediaType"].(string); ok {
                        switch mediaType {
                        case "banner":
                            return openrtb_ext.BidTypeBanner, nil
                        case "video":
                            return openrtb_ext.BidTypeVideo, nil
                        case "native":
                            return openrtb_ext.BidTypeNative, nil
                        case "audio":
                            return openrtb_ext.BidTypeAudio, nil
                        }
                    }
                }
            }
            
            // Infer from impression
            if imp.Banner != nil {
                return openrtb_ext.BidTypeBanner, nil
            } else if imp.Video != nil {
                return openrtb_ext.BidTypeVideo, nil
            } else if imp.Native != nil {
                return openrtb_ext.BidTypeNative, nil
            } else if imp.Audio != nil {
                return openrtb_ext.BidTypeAudio, nil
            }
            
            return "", &errortypes.BadServerResponse{
                Message: fmt.Sprintf("could not determine media type for bid %s", bid.ID),
            }
        }
  
  adapter_test:
    description: "Comprehensive adapter testing"
    code: |
      package example
      
      import (
          "testing"
          
          "github.com/prebid/prebid-server/v2/adapters/adapterstest"
          "github.com/prebid/prebid-server/v2/config"
          "github.com/prebid/prebid-server/v2/openrtb_ext"
          "github.com/stretchr/testify/assert"
      )
      
      func TestJsonSamples(t *testing.T) {
          bidder, buildErr := Builder(openrtb_ext.BidderExample, config.Adapter{
              Endpoint: "https://example.com/bid",
          }, config.Server{})
          
          if buildErr != nil {
              t.Fatalf("Builder returned unexpected error %v", buildErr)
          }
          
          adapterstest.RunJSONBidderTest(t, "exampletest", bidder)
      }
      
      func TestMakeRequests(t *testing.T) {
          // Test various request scenarios
          testCases := []struct {
              name          string
              request       *openrtb2.BidRequest
              expectedReqs  int
              expectedErrs  int
          }{
              {
                  name:         "simple banner request",
                  request:      makeBannerRequest(),
                  expectedReqs: 1,
                  expectedErrs: 0,
              },
              {
                  name:         "multi-impression request",
                  request:      makeMultiImpRequest(),
                  expectedReqs: 1,
                  expectedErrs: 0,
              },
              {
                  name:         "invalid request - no impressions",
                  request:      makeInvalidRequest(),
                  expectedReqs: 0,
                  expectedErrs: 1,
              },
          }
          
          for _, tc := range testCases {
              t.Run(tc.name, func(t *testing.T) {
                  adapter := &adapter{endpoint: "https://example.com/bid"}
                  reqs, errs := adapter.MakeRequests(tc.request, nil)
                  
                  assert.Len(t, reqs, tc.expectedReqs)
                  assert.Len(t, errs, tc.expectedErrs)
              })
          }
      }
  
  openrtb_extension:
    description: "OpenRTB extension for bidder parameters"
    code: |
      package openrtb_ext
      
      import (
          "encoding/json"
      )
      
      // ExtImpExample defines the contract for bidrequest.imp[i].ext.prebid.bidder.example
      type ExtImpExample struct {
          PlacementID string `json:"placementId"`
          SiteID      string `json:"siteId,omitempty"`
          AccountID   string `json:"accountId,omitempty"`
          BidFloor    float64 `json:"bidFloor,omitempty"`
      }
      
      // Validate ensures the extension parameters are valid
      func (ext *ExtImpExample) Validate() error {
          if ext.PlacementID == "" {
              return ValidationError("placementId is required")
          }
          
          if ext.BidFloor < 0 {
              return ValidationError("bidFloor must be non-negative")
          }
          
          return nil
      }
  
  stored_request_fetcher:
    description: "Fetch stored request configurations"
    code: |
      package stored_requests
      
      import (
          "context"
          "encoding/json"
          "fmt"
          
          "github.com/prebid/prebid-server/v2/stored_requests"
      )
      
      type fetcher struct {
          client  stored_requests.Fetcher
          cache   stored_requests.Cache
      }
      
      func (f *fetcher) FetchRequests(ctx context.Context, requestIDs []string, impIDs []string) (
          requestData map[string]json.RawMessage,
          impData map[string]json.RawMessage,
          errs []error,
      ) {
          // Check cache first
          if f.cache != nil {
              requestData, impData = f.cache.Get(ctx, requestIDs, impIDs)
          }
          
          // Fetch missing data
          missingReqs := findMissing(requestIDs, requestData)
          missingImps := findMissing(impIDs, impData)
          
          if len(missingReqs) > 0 || len(missingImps) > 0 {
              fetchedReqs, fetchedImps, fetchErrs := f.client.FetchRequests(ctx, missingReqs, missingImps)
              
              // Update cache
              if f.cache != nil && len(fetchErrs) == 0 {
                  f.cache.Save(ctx, fetchedReqs, fetchedImps)
              }
              
              // Merge results
              requestData = merge(requestData, fetchedReqs)
              impData = merge(impData, fetchedImps)
              errs = append(errs, fetchErrs...)
          }
          
          return requestData, impData, errs
      }

# Common patterns and best practices
patterns:
  error_handling:
    typed_errors:
      description: "Use typed errors for different scenarios"
      example: |
        import "github.com/prebid/prebid-server/v2/errortypes"
        
        // Bad input from client
        &errortypes.BadInput{
            Message: "missing required field: placementId",
        }
        
        // Bad response from bidder
        &errortypes.BadServerResponse{
            Message: "invalid JSON in response",
        }
        
        // Timeout
        &errortypes.Timeout{
            Message: "bidder request timeout",
        }
    
    error_aggregation:
      description: "Collect multiple errors without stopping"
      example: |
        var errors []error
        for _, imp := range request.Imp {
            if err := validateImp(imp); err != nil {
                errors = append(errors, err)
                continue // Process remaining impressions
            }
        }
  
  request_modification:
    copy_before_modify:
      description: "Always copy before modifying request"
      example: |
        requestCopy := *request
        // Modify requestCopy, not original
    
    impression_processing:
      description: "Process impressions individually"
      example: |
        for i := range request.Imp {
            imp := &request.Imp[i]
            // Process imp
        }
  
  testing:
    json_tests:
      description: "Use JSON test files for scenarios"
      structure: |
        adapters/example/exampletest/
        ├── exemplary/
        │   ├── simple-banner.json
        │   ├── simple-video.json
        │   └── multi-format.json
        └── supplemental/
            ├── bad-request.json
            ├── timeout.json
            └── invalid-response.json
    
    test_utilities:
      description: "Use adapter test framework"
      example: |
        adapterstest.RunJSONBidderTest(t, "exampletest", bidder)

# Configuration
configuration:
  adapter_config:
    yaml_structure: |
      adapters:
        example:
          endpoint: "https://bid.example.com/rtb"
          geoscope:
            - USA
            - CAN
          disabled: false
          extra_info:
            supports_video: true
            supports_deals: true
    
    runtime_config: |
      type: example
      endpoint: "${EXAMPLE_ENDPOINT}"
      usersync:
        iframe:
          url: "https://sync.example.com/iframe"
          redirect_url: "/setuid?bidder=example&uid={{uid}}"
        redirect:
          url: "https://sync.example.com/redirect"
  
  stored_requests:
    structure: |
      {
        "id": "example-request",
        "imp": [{
          "id": "1",
          "banner": {
            "format": [{"w": 300, "h": 250}]
          },
          "ext": {
            "prebid": {
              "bidder": {
                "example": {
                  "placementId": "12345"
                }
              }
            }
          }
        }]
      }

# Testing requirements
testing:
  required_tests:
    adapter_tests:
      - "JSON sample tests covering all scenarios"
      - "Unit tests for MakeRequests"
      - "Unit tests for MakeBids"
      - "Parameter validation tests"
    
    integration_tests:
      - "Full auction flow"
      - "Stored request handling"
      - "Multi-bidder scenarios"
  
  test_data:
    location: "adapters/{bidder}/{bidder}test/"
    exemplary: "Happy path test cases"
    supplemental: "Error and edge cases"
  
  assertions:
    - "Correct number of requests generated"
    - "Proper error types returned"
    - "Response parsing accuracy"
    - "Media type detection"

# Performance considerations
performance:
  guidelines:
    - "Use goroutines for parallel processing"
    - "Implement request coalescing"
    - "Cache frequently accessed data"
    - "Use connection pooling"
    - "Implement circuit breakers"
  
  metrics:
    - "Request latency"
    - "Adapter timeout rate"
    - "Error rates by type"
    - "Request/response sizes"
  
  optimization:
    request_building: |
      // Pre-allocate slices
      requests := make([]*adapters.RequestData, 0, len(imps))
    
    json_handling: |
      // Use json.RawMessage for unknown fields
      type BidExt struct {
          Prebid *ExtBidPrebid `json:"prebid,omitempty"`
          Extra  json.RawMessage `json:"extra,omitempty"`
      }

# Compliance and privacy
compliance:
  gdpr:
    handling: |
      if request.Regs != nil && request.Regs.Ext != nil {
          var regsExt openrtb_ext.ExtRegs
          json.Unmarshal(request.Regs.Ext, &regsExt)
          if regsExt.GDPR != nil && *regsExt.GDPR == 1 {
              // Handle GDPR
          }
      }
  
  ccpa:
    handling: |
      if request.Regs != nil && request.Regs.Ext != nil {
          var regsExt openrtb_ext.ExtRegs
          json.Unmarshal(request.Regs.Ext, &regsExt)
          if regsExt.USPrivacy != "" {
              // Handle CCPA
          }
      }
  
  coppa:
    handling: |
      if request.Regs != nil && request.Regs.COPPA == 1 {
          // Handle COPPA
      }

# Common issues and solutions
troubleshooting:
  common_errors:
    json_parsing:
      issue: "Failed to unmarshal bid response"
      solution: "Validate JSON structure, check for extra fields"
      debugging: "Log raw response body"
    
    timeout:
      issue: "Adapter timeouts"
      solution: "Implement proper context handling"
      example: |
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
    
    parameter_validation:
      issue: "Invalid adapter parameters"
      solution: "Implement thorough validation in params_test.go"