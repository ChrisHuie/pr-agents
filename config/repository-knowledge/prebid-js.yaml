repository: prebid/Prebid.js
type: prebid-js
description: Header bidding library for programmatic advertising
version: 9.x
primary_language: JavaScript
ecosystem: Web/Browser

# Repository overview
overview:
  purpose: "Client-side header bidding solution for web publishers"
  key_features:
    - "Real-time bidding auctions in the browser"
    - "Multi-format support (banner, video, native)"
    - "150+ integrated demand partners (SSPs/DSPs)"
    - "Privacy compliance (GDPR, CCPA, USP)"
    - "Advanced monetization features (price floors, analytics)"
  
  architecture:
    core_components:
      - auction_manager: "Manages bid auctions and timing"
      - adapter_manager: "Loads and manages bid adapters"
      - ad_server_manager: "Integrates with ad servers (GAM, etc)"
      - user_sync_manager: "Handles cookie syncing"
      - consent_manager: "Privacy and consent handling"
    
    module_system:
      - bid_adapters: "Connect to demand sources"
      - analytics_adapters: "Track performance metrics"
      - user_id_modules: "Identity solutions"
      - rtd_modules: "Real-time data providers"
      - video_modules: "Video player integrations"

# Directory structure
directory_structure:
  src:
    description: "Core library code"
    subdirectories:
      - adapters: "Base adapter classes and factories"
      - ajax: "Network request handling"
      - auction: "Auction logic and bid management"
      - config: "Configuration management"
      - events: "Event system"
      - prebid: "Main entry point"
      - utils: "Utility functions"
      - video: "Video-specific functionality"
  
  modules:
    description: "Plugin modules (adapters, analytics, etc)"
    patterns:
      - "*BidAdapter.js": "Bid adapters for SSPs/DSPs"
      - "*AnalyticsAdapter.js": "Analytics providers"
      - "*IdSystem.js": "User ID systems"
      - "*RtdProvider.js": "Real-time data providers"
  
  libraries:
    description: "Shared libraries and utilities"
    examples:
      - "chunk/": "Code splitting utilities"
      - "creative-renderer/": "Creative rendering logic"
      - "events/": "Event handling"
      - "ortb/": "OpenRTB utilities"
  
  test:
    description: "Test files and fixtures"
    structure:
      - "spec/modules/": "Unit tests for modules"
      - "spec/unit/": "Core unit tests"
      - "spec/integration/": "Integration tests"
      - "fixtures/": "Test data and mocks"

# Code examples with full context
code_examples:
  bid_adapter:
    complete_example:
      description: "Full-featured bid adapter with all capabilities"
      code: |
        /**
         * @module modules/exampleBidAdapter
         * @requires src/adapters/bidderFactory
         */
        import { registerBidder } from '../src/adapters/bidderFactory.js';
        import { BANNER, VIDEO, NATIVE } from '../src/mediaTypes.js';
        import { config } from '../src/config.js';
        import { deepAccess, isArray, logError, logWarn, parseUrl, triggerPixel } from '../src/utils.js';
        import { ortbConverter } from '../libraries/ortbConverter/converter.js';
        import { storage } from '../src/storageManager.js';
        
        const BIDDER_CODE = 'example';
        const ENDPOINT_URL = 'https://ssp.example.com/hb/v1';
        const GVLID = 123; // Global Vendor List ID for GDPR
        const COOKIE_NAME = 'example_uid';
        const SUPPORTED_AD_TYPES = [BANNER, VIDEO, NATIVE];
        
        // Storage for user ID
        const exampleStorage = storage({
          bidderCode: BIDDER_CODE,
          gvlid: GVLID
        });
        
        export const spec = {
          code: BIDDER_CODE,
          gvlid: GVLID,
          supportedMediaTypes: SUPPORTED_AD_TYPES,
          aliases: ['exampleAlias'], // Optional aliases
          
          /**
           * Determines whether or not the given bid request is valid
           * @param {BidRequest} bid The bid params to validate
           * @return boolean True if this is a valid bid, and false otherwise
           */
          isBidRequestValid: function(bid) {
            // Check for required parameters
            if (!bid.params) {
              logError(`${BIDDER_CODE}: bid.params is required`);
              return false;
            }
            
            if (!bid.params.publisherId) {
              logError(`${BIDDER_CODE}: bid.params.publisherId is required`);
              return false;
            }
            
            // Validate publisherId format
            if (typeof bid.params.publisherId !== 'string' || !bid.params.publisherId.match(/^[0-9a-zA-Z]+$/)) {
              logError(`${BIDDER_CODE}: bid.params.publisherId must be an alphanumeric string`);
              return false;
            }
            
            // Optional: validate placement ID if provided
            if (bid.params.placementId && typeof bid.params.placementId !== 'string') {
              logWarn(`${BIDDER_CODE}: bid.params.placementId should be a string`);
            }
            
            return true;
          },
          
          /**
           * Make a server request from the list of BidRequests
           * @param {BidRequest[]} validBidRequests - array of bids
           * @param {BidderRequest} bidderRequest - master bid request object
           * @return ServerRequest Info describing the request to the server
           */
          buildRequests: function(validBidRequests, bidderRequest) {
            // Group requests by publisher ID for efficiency
            const requestsByPublisher = {};
            
            validBidRequests.forEach(bid => {
              const publisherId = bid.params.publisherId;
              if (!requestsByPublisher[publisherId]) {
                requestsByPublisher[publisherId] = [];
              }
              requestsByPublisher[publisherId].push(bid);
            });
            
            // Build requests for each publisher
            const requests = [];
            
            Object.keys(requestsByPublisher).forEach(publisherId => {
              const bidRequests = requestsByPublisher[publisherId];
              
              // Build request payload
              const payload = {
                id: bidderRequest.bidderRequestId,
                publisherId: publisherId,
                site: {
                  domain: parseUrl(bidderRequest.refererInfo.page).hostname,
                  page: bidderRequest.refererInfo.page,
                  ref: bidderRequest.refererInfo.ref
                },
                device: {
                  ua: navigator.userAgent,
                  js: 1,
                  dnt: navigator.doNotTrack === '1' ? 1 : 0,
                  h: screen.height,
                  w: screen.width,
                  language: navigator.language
                },
                imp: bidRequests.map(bid => buildImpression(bid)),
                test: config.getConfig('debug') ? 1 : 0,
                tmax: bidderRequest.timeout
              };
              
              // Add user ID if available
              const userId = getUserId();
              if (userId) {
                payload.user = { id: userId };
              }
              
              // Add GDPR consent
              if (bidderRequest.gdprConsent) {
                payload.regs = {
                  ext: {
                    gdpr: bidderRequest.gdprConsent.gdprApplies ? 1 : 0
                  }
                };
                payload.user = payload.user || {};
                payload.user.ext = {
                  consent: bidderRequest.gdprConsent.consentString
                };
              }
              
              // Add USP consent
              if (bidderRequest.uspConsent) {
                payload.regs = payload.regs || {};
                payload.regs.ext = payload.regs.ext || {};
                payload.regs.ext.us_privacy = bidderRequest.uspConsent;
              }
              
              requests.push({
                method: 'POST',
                url: ENDPOINT_URL,
                data: JSON.stringify(payload),
                options: {
                  contentType: 'application/json',
                  withCredentials: true
                },
                bidderRequest: bidderRequest
              });
            });
            
            return requests;
          },
          
          /**
           * Unpack the response from the server into a list of bids
           * @param {ServerResponse} serverResponse A successful response from the server
           * @param {BidRequest} bidRequest The request that was sent to the server
           * @return {Bid[]} An array of bids which were nested inside the server
           */
          interpretResponse: function(serverResponse, bidRequest) {
            const bidResponses = [];
            const response = serverResponse.body;
            
            if (!response || !response.seatbid || !isArray(response.seatbid)) {
              logWarn(`${BIDDER_CODE}: No valid bids in response`);
              return bidResponses;
            }
            
            response.seatbid.forEach(seatbid => {
              if (seatbid.bid && isArray(seatbid.bid)) {
                seatbid.bid.forEach(bid => {
                  const bidResponse = {
                    requestId: bid.impid,
                    cpm: parseFloat(bid.price),
                    width: bid.w,
                    height: bid.h,
                    creativeId: bid.crid || bid.id,
                    dealId: bid.dealid,
                    currency: response.cur || 'USD',
                    netRevenue: true,
                    ttl: 300,
                    meta: {
                      advertiserDomains: bid.adomain || [],
                      primaryCatId: bid.cat && bid.cat[0],
                      networkId: bid.ext && bid.ext.networkId
                    }
                  };
                  
                  // Set media type specific fields
                  if (bid.ext && bid.ext.mediaType === 'video') {
                    bidResponse.mediaType = VIDEO;
                    bidResponse.vastUrl = bid.nurl;
                    bidResponse.vastXml = bid.adm;
                  } else if (bid.ext && bid.ext.mediaType === 'native') {
                    bidResponse.mediaType = NATIVE;
                    bidResponse.native = parseNativeResponse(bid.adm);
                  } else {
                    bidResponse.mediaType = BANNER;
                    bidResponse.ad = bid.adm;
                  }
                  
                  // Add renderer for outstream video
                  if (bidResponse.mediaType === VIDEO && bid.ext && bid.ext.videoType === 'outstream') {
                    bidResponse.renderer = createRenderer(bidResponse, bid);
                  }
                  
                  // Add notification URLs
                  if (bid.nurl) bidResponse.nurl = bid.nurl;
                  if (bid.burl) bidResponse.burl = bid.burl;
                  if (bid.lurl) bidResponse.lurl = bid.lurl;
                  
                  bidResponses.push(bidResponse);
                });
              }
            });
            
            return bidResponses;
          },
          
          /**
           * Register user sync pixels
           * @param {SyncOptions} syncOptions Which sync methods are allowed
           * @param {ServerResponse[]} serverResponses List of server's responses
           * @param {Object} gdprConsent GDPR consent object
           * @param {string} uspConsent USP consent string
           * @return {UserSync[]} The user syncs that should be dropped
           */
          getUserSyncs: function(syncOptions, serverResponses, gdprConsent, uspConsent) {
            const syncs = [];
            const gdprParams = gdprConsent ? `&gdpr=${gdprConsent.gdprApplies ? 1 : 0}&gdpr_consent=${gdprConsent.consentString}` : '';
            const uspParams = uspConsent ? `&us_privacy=${uspConsent}` : '';
            
            if (syncOptions.iframeEnabled) {
              syncs.push({
                type: 'iframe',
                url: `https://sync.example.com/iframe?pbjs=1${gdprParams}${uspParams}`
              });
            }
            
            if (syncOptions.pixelEnabled) {
              serverResponses.forEach(response => {
                const syncUrls = deepAccess(response, 'body.ext.sync.pixel');
                if (isArray(syncUrls)) {
                  syncUrls.forEach(url => {
                    syncs.push({
                      type: 'image',
                      url: url + gdprParams + uspParams
                    });
                  });
                }
              });
            }
            
            return syncs;
          },
          
          /**
           * Register bidder specific code, which will execute when bid wins
           * @param {Bid} bid The bid that won the auction
           */
          onBidWon: function(bid) {
            if (bid.nurl) {
              triggerPixel(bid.nurl);
            }
            logInfo(`${BIDDER_CODE}: Bid won for placement ${bid.adUnitCode}`);
          },
          
          /**
           * Register bidder specific code, which will execute if bidder timed out
           * @param {BidRequest[]} timeoutData List of bids that timed out
           */
          onTimeout: function(timeoutData) {
            logWarn(`${BIDDER_CODE}: Timeout for`, timeoutData);
            // Send timeout notification to server
            const url = `${ENDPOINT_URL}/timeout`;
            const payload = {
              bidders: timeoutData.map(bid => ({
                bidder: bid.bidder,
                adunit: bid.adUnitCode,
                timeout: bid.timeout
              }))
            };
            
            // Fire and forget
            navigator.sendBeacon(url, JSON.stringify(payload));
          },
          
          /**
           * Register bidder specific code, which will execute if bidder errors
           * @param {Object} error Error object
           * @param {BidRequest} bidRequest The bid request that caused the error
           */
          onBidderError: function({ error, bidderRequest }) {
            logError(`${BIDDER_CODE}: Bidder error`, error);
          }
        };
        
        // Helper functions
        function buildImpression(bid) {
          const imp = {
            id: bid.bidId,
            tagid: bid.params.placementId || bid.adUnitCode,
            secure: 1
          };
          
          // Add media types
          if (deepAccess(bid, 'mediaTypes.banner')) {
            imp.banner = {
              format: bid.sizes.map(size => ({ w: size[0], h: size[1] }))
            };
          }
          
          if (deepAccess(bid, 'mediaTypes.video')) {
            imp.video = {
              mimes: bid.mediaTypes.video.mimes || ['video/mp4'],
              protocols: bid.mediaTypes.video.protocols || [2, 3, 5, 6],
              w: bid.mediaTypes.video.playerSize[0][0],
              h: bid.mediaTypes.video.playerSize[0][1]
            };
          }
          
          if (deepAccess(bid, 'mediaTypes.native')) {
            imp.native = {
              request: JSON.stringify(bid.mediaTypes.native)
            };
          }
          
          // Add floor price if available
          if (typeof bid.getFloor === 'function') {
            const floor = bid.getFloor({
              currency: 'USD',
              mediaType: '*',
              size: '*'
            });
            
            if (floor && floor.floor && floor.currency) {
              imp.bidfloor = floor.floor;
              imp.bidfloorcur = floor.currency;
            }
          }
          
          return imp;
        }
        
        function getUserId() {
          return exampleStorage.getCookie(COOKIE_NAME);
        }
        
        function parseNativeResponse(adm) {
          try {
            return JSON.parse(adm);
          } catch (e) {
            logError(`${BIDDER_CODE}: Error parsing native response`, e);
            return null;
          }
        }
        
        registerBidder(spec);

  analytics_adapter:
    description: "Analytics adapter for tracking auction events"
    code: |
      import adapter from '../src/AnalyticsAdapter.js';
      import adapterManager from '../src/adapterManager.js';
      import { ajax } from '../src/ajax.js';
      import { config } from '../src/config.js';
      import * as utils from '../src/utils.js';
      
      const analyticsType = 'endpoint';
      const ANALYTICS_URL = 'https://analytics.example.com/collect';
      
      let exampleAnalytics = Object.assign(adapter({url: ANALYTICS_URL, analyticsType}), {
        track({eventType, args}) {
          switch (eventType) {
            case 'auctionInit':
              handleAuctionInit(args);
              break;
            case 'bidRequested':
              handleBidRequested(args);
              break;
            case 'bidResponse':
              handleBidResponse(args);
              break;
            case 'bidWon':
              handleBidWon(args);
              break;
            case 'auctionEnd':
              handleAuctionEnd(args);
              break;
          }
        }
      });
      
      // Analytics handlers implementation...
      
      adapterManager.registerAnalyticsAdapter({
        adapter: exampleAnalytics,
        code: 'example'
      });

  user_id_module:
    description: "User ID module for identity management"
    code: |
      import { submodule } from '../src/hook.js';
      import { ajax } from '../src/ajax.js';
      import { getStorageManager } from '../src/storageManager.js';
      
      const MODULE_NAME = 'exampleId';
      const storage = getStorageManager({moduleType: 'userId', moduleName: MODULE_NAME});
      
      export const exampleIdSubmodule = {
        name: MODULE_NAME,
        
        decode(value) {
          return value ? { exampleId: value } : undefined;
        },
        
        getId(config, consentData) {
          const id = storage.getCookie('example_id');
          if (id) {
            return { id };
          }
          
          return {
            callback: function(cb) {
              ajax('https://id.example.com/get', {
                success: response => {
                  const id = JSON.parse(response).id;
                  storage.setCookie('example_id', id, 30);
                  cb(id);
                },
                error: () => cb()
              });
            }
          };
        }
      };
      
      submodule('userId', exampleIdSubmodule);

  rtd_module:
    description: "Real-time data provider module"
    code: |
      import { submodule } from '../src/hook.js';
      import { ajax } from '../src/ajax.js';
      import { getGlobal } from '../src/prebidGlobal.js';
      
      function init(config, userConsent) {
        return true;
      }
      
      function getBidRequestData(reqBidsConfigObj, callback, config, userConsent) {
        ajax('https://rtd.example.com/data', {
          success: response => {
            const data = JSON.parse(response);
            // Add data to ad units
            reqBidsConfigObj.adUnits.forEach(adUnit => {
              adUnit.rtd = adUnit.rtd || {};
              adUnit.rtd.example = data;
            });
            callback();
          },
          error: () => callback()
        });
      }
      
      export const exampleRtdProvider = {
        name: 'example',
        init: init,
        getBidRequestData: getBidRequestData
      };
      
      submodule('realTimeData', exampleRtdProvider);

# Common patterns and best practices
patterns:
  error_handling:
    try_catch:
      description: "Wrap JSON parsing and external calls"
      example: |
        try {
          const data = JSON.parse(response);
          return processData(data);
        } catch (e) {
          utils.logError('Failed to parse response', e);
          return null;
        }
    
    validation:
      description: "Validate inputs before processing"
      example: |
        if (!utils.isArray(bids)) {
          utils.logWarn('Expected array of bids');
          return [];
        }
  
  consent_handling:
    gdpr:
      description: "Handle GDPR consent properly"
      example: |
        if (bidderRequest.gdprConsent) {
          payload.gdpr = bidderRequest.gdprConsent.gdprApplies ? 1 : 0;
          payload.gdpr_consent = bidderRequest.gdprConsent.consentString;
        }
    
    usp:
      description: "Handle USP/CCPA consent"
      example: |
        if (bidderRequest.uspConsent) {
          payload.us_privacy = bidderRequest.uspConsent;
        }
  
  performance:
    batch_requests:
      description: "Batch multiple bid requests when possible"
      example: |
        // Group by endpoint or configuration
        const grouped = validBidRequests.reduce((acc, bid) => {
          const key = bid.params.endpoint;
          acc[key] = acc[key] || [];
          acc[key].push(bid);
          return acc;
        }, {});
    
    timeout_handling:
      description: "Respect auction timeout"
      example: |
        payload.tmax = Math.min(bidderRequest.timeout, 1000);

# Testing requirements
testing:
  required_coverage:
    unit_tests:
      - "isBidRequestValid with valid/invalid params"
      - "buildRequests with single/multiple bids"
      - "interpretResponse with various response formats"
      - "getUserSyncs with different consent scenarios"
    
    edge_cases:
      - "Empty responses"
      - "Malformed responses"
      - "Missing required fields"
      - "Timeout scenarios"
  
  test_structure:
    imports: |
      import { expect } from 'chai';
      import { spec } from 'modules/exampleBidAdapter.js';
      import { newBidder } from 'src/adapters/bidderFactory.js';
      import * as utils from 'src/utils.js';
      import { config } from 'src/config.js';
    
    describe_blocks:
      - "describe('isBidRequestValid', function() {...})"
      - "describe('buildRequests', function() {...})"
      - "describe('interpretResponse', function() {...})"
      - "describe('getUserSyncs', function() {...})"
      - "describe('onBidWon', function() {...})"
      - "describe('onTimeout', function() {...})"

# API and integration points
apis:
  prebid_apis:
    bidder_factory:
      - registerBidder: "Register adapter with Prebid"
      - newBidder: "Create bidder instance for testing"
    
    utils:
      - deepAccess: "Safe nested property access"
      - isArray: "Array type checking"
      - logError/logWarn/logInfo: "Logging utilities"
      - parseUrl: "URL parsing"
      - triggerPixel: "Fire tracking pixels"
      - generateUUID: "Generate unique IDs"
    
    storage:
      - getCookie/setCookie: "Cookie management"
      - getDataFromLocalStorage: "Local storage access"
      - hasDeviceAccess: "Check storage permissions"
    
    config:
      - getConfig: "Get Prebid configuration"
      - getBidderConfig: "Get bidder-specific config"
  
  events:
    auction_events:
      - AUCTION_INIT: "Auction started"
      - BID_REQUESTED: "Bid requested from adapter"
      - BID_RESPONSE: "Bid received"
      - BID_WON: "Bid won auction"
      - AUCTION_END: "Auction completed"
      - BID_TIMEOUT: "Bid timed out"
    
    adapter_events:
      - BIDDER_ERROR: "Adapter error occurred"
      - SET_TARGETING: "Targeting keys set"
      - REQUEST_BIDS: "Bid request initiated"

# Common issues and solutions
troubleshooting:
  common_errors:
    cors:
      issue: "Cross-origin requests blocked"
      solution: "Ensure server has proper CORS headers"
      example: "Access-Control-Allow-Origin: *"
    
    timeout:
      issue: "Bids timing out frequently"
      solution: "Optimize server response time, respect timeout param"
      debugging: "Check bidderRequest.timeout value"
    
    parsing:
      issue: "JSON parsing errors"
      solution: "Always use try-catch, validate response format"
    
    consent:
      issue: "Missing consent handling"
      solution: "Check bidderRequest.gdprConsent and uspConsent"

# Performance optimization
optimization:
  request_optimization:
    - "Batch multiple ad units in single request"
    - "Use gzip compression for requests/responses"
    - "Implement request caching where appropriate"
    - "Minimize payload size"
  
  response_optimization:
    - "Return only winning bids from server"
    - "Use compact response format"
    - "Implement server-side filtering"
  
  client_optimization:
    - "Use Web Workers for heavy processing"
    - "Implement lazy loading for adapters"
    - "Cache user IDs and segments"

# Compliance and privacy
compliance:
  gdpr:
    required_fields:
      - "gvlid: Global Vendor List ID"
      - "Purpose consents handling"
      - "Vendor consent checking"
    
    implementation: |
      import { gdprDataHandler } from '../src/adapterManager.js';
      
      const consent = gdprDataHandler.getConsentData();
      if (consent && consent.gdprApplies) {
        // Handle GDPR logic
      }
  
  ccpa_usp:
    implementation: |
      import { uspDataHandler } from '../src/adapterManager.js';
      
      const uspConsent = uspDataHandler.getConsentData();
      if (uspConsent) {
        // Format: "1YNN" (version, opt-out, sale, sharing)
      }
  
  coppa:
    implementation: |
      const coppa = config.getConfig('coppa');
      if (coppa) {
        // Disable user tracking
      }

# Module metadata
metadata:
  required_fields:
    code: "Unique bidder code"
    gvlid: "IAB Global Vendor List ID"
    supportedMediaTypes: "Array of BANNER, VIDEO, NATIVE"
  
  optional_fields:
    aliases: "Alternative bidder codes"
    isBidRequestValid: "Validate bid parameters"
    buildRequests: "Build server requests"
    interpretResponse: "Parse server responses"
    getUserSyncs: "Return sync pixels"
    onBidWon: "Handle winning bids"
    onTimeout: "Handle timeouts"
    onBidderError: "Handle errors"
    onSetTargeting: "Handle targeting"

# Version compatibility
compatibility:
  prebid_versions:
    "7.x": "Current major version"
    "8.x": "Latest features"
    "9.x": "Next generation"
  
  breaking_changes:
    "7.0": "Removed legacy auction methods"
    "8.0": "New consent management"
    "9.0": "Modular core architecture"